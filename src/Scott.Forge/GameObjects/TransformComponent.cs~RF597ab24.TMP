/*
 * Copyright 2012-2017 Scott MacDonald
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace Scott.Forge.GameObjects
{
    /// <summary>
    ///  Hierarchical 2d transformation component. Holds the position, rotation and scale of an object relative to the
    ///  parent and the world.
    /// </summary>
    /// <remarks>
    ///  Transform uses the Forge engine inverted Y coordinate system (eg +Y faces down and -Y faces up). This affects
    ///  properties such as Left and Right since the default rotation 0 degrees faces the +X axis.
    /// </remarks>
    public class TransformComponent : Component
    {
        // Default scale is one, never zero.
        public static readonly Vector2 DefaultScale = Vector2.One;

        /// <summary>
        ///  Offset from local origin.
        /// </summary>
        private Vector2 mLocalPosition = Vector2.Zero;

        /// <summary>
        ///  Offset from world origin. Calculate as parent.WorldPosition + this.LocalPosition.
        /// </summary>
        private Vector2 mWorldPosition = Vector2.Zero;

        private float mLocalRotation = 0.0f;
        private float mWorldRotation = 0.0f;

        private Vector2 mLocalScale = Vector2.One;
        private Vector2 mWorldScale = Vector2.One;

        // Cached from mWorldRotation.
        private Vector2 mWorldForward;        

        /// <summary>
        ///  Constructor.
        /// </summary>
        public TransformComponent()
        {
        }

        /// <summary>
        ///  Get a unit vector from the transform oriented toward the -X axis.
        /// </summary>
        public Vector2 Backward { get { return -mWorldForward; } }

        /// <summary>
        ///  World direction.
        /// </summary>
        /// <remarks>
        ///  TODO: REMOVE.
        /// </remarks>
        public DirectionName Direction
        {
            get
            {
                return DirectionNameHelper.FromRotationDegrees(mWorldRotation);
            }
            set
            {
                mLocalRotation = MathHelper.DegreeToRadian(value.ToRotationDegrees());
                mWorldForward = value.ToVector();
                mWorldRotation = mLocalRotation;
            }
        }

        /// <summary>
        ///  Get a unit vector from the transform oriented toward the +X axis.
        /// </summary>
        public Vector2 Forward { get { return mWorldForward; } }

        /// <summary>
        ///  Get or set the position of this transform relative to the parent.
        /// </summary>
        public Vector2 LocalPosition
        {
            get { return mLocalPosition; }
            set
            {
                mLocalPosition = value;
            }
        }

        /// <summary>
        ///  Get or set the world position.
        /// </summary>
        public Vector2 Position
        {
            get { return mWorldPosition; }
            set
            {
                if (!mWorldPosition.Equals(value))
                {
                    if (Owner != null && Owner.Parent != null)
                    {
                        mLocalPosition = value - mWorldPosition;
                    }
                    else
                    {
                        mLocalPosition = Vector2.Zero;
                    }

                    mWorldPosition = value;

                    RecalculateChildTransforms();
                }
            }
        }




        /// <summary>
        ///  Right vector in world space.
        /// </summary>
        public Vector2 Right { get { return new Vector2(-mWorldForward.Y, mWorldForward.X); } }

        /// <summary>
        ///  Left vector in world space.
        /// </summary>
        public Vector2 Left { get { return new Vector2(mWorldForward.Y, -mWorldForward.X); } }

        /// <summary>
        ///  Rotation relative to world origin.
        /// </summary>
        public float Rotation
        {
            get { return mWorldRotation; }
            set
            {
                // TODO: Wrap angle.
                mWorldRotation = value;
                mWorldForward = MathHelper.Rotate(0, 1, (float)Math.PI * 2.0f - value);
            }
        }

        /// <summary>
        ///  Local scale, relative to parent transform.
        /// </summary>
        public Vector2 Scale { get { return mLocalScale; } }



        /// <summary>
        ///  Move the transform in the requested distance, relative to the transform's current
        ///  rotation.
        /// </summary>
        /// <param name="distance">Distance to move.</param>
        public void Translate( Vector2 distance )
        {
            Position += distance;
        }

        /// <summary>
        ///  Transforms the provided rotation vector from local space into world space.
        /// </summary>
        /// <param name="direction">Local space direction.</param>
        /// <returns>World space direction vector</returns>
        public Vector2 TransformDirection( Vector2 direction )
        {
            return MathHelper.Rotate( direction, mWorldRotation );
        }

        /// <summary>
        ///  Transforms the provided position vector from local space into world space.
        /// </summary>
        /// <param name="position">Position vector.</param>
        /// <returns>World space position vector.</returns>
        public Vector2 TransformPosition( Vector2 position )
        {
            Vector2 rPos = mLocalPosition + MathHelper.Rotate( position - mLocalPosition, mWorldRotation );
            return mWorldPosition + rPos;
        }

        /// <summary>
        ///  Called when game object owner's parent is changed.
        /// </summary>
        /// <param name="newParent">The new parent.</param>
        /// <param name="oldParent">The old parent.</param>
        public void OnParentChanged(GameObject newParent, GameObject oldParent)
        {
            // Recalculate world position and rotation from the new parent, and then propogate changes to children.
            var parentPosition = (newParent != null ? newParent.Transform.Position : Vector2.Zero);
            var mWorldPosition = parentPosition + mLocalPosition;

            RecalculateChildTransforms();
        }

        /// <summary>
        ///  Recursively invalidate and recalculate transforms of children.
        /// </summary>
        void RecalculateChildTransforms()
        {
            // TODO.
        }
        

        /// <summary>
        ///  Convert the Transform to a human readable string.
        /// </summary>
        /// <returns>String readable transform.</returns>
        public override string ToString()
        {
            return
                "Position <{0},{1}>, Dir: {2}, Rotation: {3}, Scale: <{4},{5}>"
                    .With( Position.X, Position.Y,
                           Direction,
                           Rotation,
                           Scale.X,
                           Scale.Y );
        }
    }
}
