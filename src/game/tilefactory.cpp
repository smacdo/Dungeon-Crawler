/*
 * Copyright 2012 Scott MacDonald
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#include <vector>
#include <string>

#include "game/tilefactory.h"
#include "game/tileflags.h"
#include "game/tile.h"
#include "game/tiletype.h"
#include "common/utils.h"

/**
 * The tile factory constructor
 */
TileFactory::TileFactory()
    : mBlueprints( ETILETYPE_COUNT, 0 )
{
    TileTypeFlagSet flags;

    // Construct void tile ////////////////////////////////////////////////
    TileType *pVoidData = new TileType;
    // all void data already generated by tiletype.cpp

    mBlueprints[ pVoidData->id() ] = pVoidData;

    // Construct granite tile /////////////////////////////////////////////
    flags.reset();
    flags.set( ETILE_GRANITE );
    flags.set( ETILE_IMPASSABLE );
    flags.set( ETILE_BLOCK_LOS );
    
    mBlueprints[ ETILETYPE_GRANITE ] = new TileType( ETILETYPE_GRANITE,
                                                     "granite",
                                                     "granite wall",
                                                     flags );

    // Construct stone wall tile //////////////////////////////////////////
    flags.reset();
    flags.set( ETILE_IMPASSABLE );
    flags.set( ETILE_WALL );
    flags.set( ETILE_BLOCK_LOS );

    mBlueprints[ ETILETYPE_DUNGEON_WALL ] =
        new TileType( ETILETYPE_DUNGEON_WALL,
                      "stone_wall",
                      "Stone Wall",
                      flags );

    // Construct stone floor tile /////////////////////////////////////////
    flags.reset();
    flags.set( ETILE_WALK );
    flags.set( ETILE_FLOOR );

    mBlueprints[ ETILETYPE_DUNGEON_FLOOR ] =
        new TileType( ETILETYPE_DUNGEON_FLOOR,
                      "stone_floor",
                      "Stone Floor",
                      flags );

    // Dungeon doorway ////////////////////////////////////////////////////
    flags.reset();
    flags.set( ETILE_WALL );
    flags.set( ETILE_WALK );
    flags.set( ETILE_DOORWAY );

    mBlueprints[ ETILETYPE_DUNGEON_DOORWAY ] =
        new TileType( ETILETYPE_DUNGEON_DOORWAY,
                      "dungeon_doorway",
                      "Stone Doorway",
                      flags );

    // Construct stone tile filler tile ///////////////////////////////////
    flags.reset();
    flags.set( ETILE_IMPASSABLE );
    flags.set( ETILE_BLOCK_LOS );

    mBlueprints[ ETILETYPE_FILLER_STONE ] =
        new TileType( ETILETYPE_FILLER_STONE,
                      "filler_stone",
                      "Stone Rock",
                      flags );
}

/**
 * Tile factory destructor
 */
TileFactory::~TileFactory()
{
    DeleteVectorPointers( mBlueprints );
}

/**
 * Create and return a void tile
 */
Tile TileFactory::createVoid() const
{
    TileType *pTileType = mBlueprints[ ETILETYPE_VOID ];
    assert( pTileType != NULL );

    return Tile( pTileType );
}

/**
 * Create and return a granite tile
 */
Tile TileFactory::createGranite() const
{
    TileType *pTileType = mBlueprints[ ETILETYPE_GRANITE ];
    assert( pTileType != NULL );

    return Tile( pTileType );
}

/**
 * Create and return generic "filler" tiles (stuff that exists in the empty area
 * inbetween dungeon rooms/halls
 */
Tile TileFactory::createFiller() const
{
    TileType *pTileType = mBlueprints[ ETILETYPE_FILLER_STONE ];
    assert( pTileType != NULL );

    return Tile( pTileType );
}

/**
 * Create and return a wall
 */
Tile TileFactory::createWall() const
{
    TileType *pTileType = mBlueprints[ ETILETYPE_DUNGEON_WALL ];
    assert( pTileType != NULL );
    
    return Tile( pTileType );
}

/**
 * Create and return a floor
 */
Tile TileFactory::createFloor() const
{
    TileType *pTileType = mBlueprints[ ETILETYPE_DUNGEON_FLOOR ];
    assert( pTileType != NULL );

    return Tile( pTileType );
}

/**
 * Create and return a door
 */
Tile TileFactory::createDoorway() const
{
    TileType *pTileType = mBlueprints[ ETILETYPE_DUNGEON_DOORWAY ];
    assert( pTileType != NULL );

    return Tile( pTileType );
}
